# Luogu P1031 均分纸牌

## 题意
给定 $n$ 牌堆，第 $i$ 堆牌有 $a_i$ 张，保证 $\sum_{i=1}^{n} a_i$ 是 $n$ 的倍数。

可以进行 $h$ 操作：选取相邻的两堆，从某一堆中拿任意张牌给另一堆，算一次操作。
求最小的操作次数，使得 $n$ 堆牌中的数量都一样。

## 题解
大家部分明确讲了如何去做，并没有讲诚心的正确性证明。导致我在做这题时，包括很多选择这题时产生了疑惑，今天专门来讲。

首先先提出一个，这样做很操蛋，所以题解里基于贪心的错误思想来说，是错误的。
但是我们可以认真思考以后依然能得出正确的结论。

首先我觉得有点奇怪，最后要求所有牌堆的数量都相等。

引用：任意两堆相邻的牌堆，最优策略是只能从一堆迁移给另一堆。不存在 $A$ 给 $B$，之后 $B$ 给 $A$。

我们可以分治的思想证明这个结论。

首先我们取两堆牌，不妨设左边为 $A$，右边为 $B$。
因为我们要求牌堆后都相等，所以可以认为这两堆减少到每堆需要的数量。

现在有三种情况。

1. $A = B = 0$：说明牌堆之间不需要进行牌的交换。
2. $A > 0 > B$：说明 $A$ 有余，$B$ 不足。
3. $A < 0 < B$：说明 $A$ 不足，$B$ 有余。

那会存在 $A = A$ 一次性把这多堆给 $B$。

这其实是一个矛盾：为何 $A$ 一定是 $A$，而不能是 $B$。

这将会引发一个问题，即（有一个比较现实的回答是与环细分顶点），这多堆其实是不合理的，这里我们存在操作次数为 $1$ 的情况。
如果我们考虑是有别的牌堆变化，这将变得完全不一样。

问题是，如果有些点本身变得平坦后，不需要迁移。那么解放出来了这连线能否还存在呢？

如果我们保持了一堆，那么这样总是能够从一个里边搬迁。
如果最后还是 $m'$，$n' - 1$ 之间。

另一方面，这张图可能是是一条链，因为珍不存在边之间所以绝不会断裂。

事情是，这张图最后形成的是有着条件链。答案就是点数就会减少，因为只要之间不需要进行交换，所以减少。因为减少的是一种，可以形成一个矛盾。那数量就被算是边数，这样就只剩下次数是确定的了。

我们发现我们最后只关注数量，不关心方向了。所以这题归用这个思想做，可以存在负数，可以较为准确地选出结果。

这题如果没有考虑这么多，只考虑愿意做的话。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

#define endl "\n"

typedef long long int;

const int N = 1e2 + 10;
int n, arr[N];

void Solve(void)
{
    cin >> n;
    int average = 0;
    for (int i = 1; i <= n; ++i)
    {
        cin >> arr[i];
        average += arr[i];
    }
    average /= n;

    int ans = 0;
    for (int i = 1; i + 1 <= n; ++i)
    {
        if (arr[i] != average)
        {
            ans++, arr[i + 1] += arr[i] - average;
        }
    }
    cout << ans << endl;

    int ans = n, sum = 0;
    for (int i = 1; i <= n; ++i)
    {
        sum += arr[i] - average;
        if (sum == 0) ans--;
    }
    cout << ans << endl;
}
```