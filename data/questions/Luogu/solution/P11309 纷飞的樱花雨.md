## T2. sakura

### 题意回顾

长度为 $n$ 的序列，经过 $k$ 次交换后，最大化数列 $n$ 个前最大值的和。

### 分析

记 $m_i = \max_{1 \leq j \leq i} a_j$，虽然有 $m_i = \max\{m_{i-1}, a_i\}$，因此可以递推出这个已交换完的数列对应的答案 $\sum_{i=1}^n m_i$；

- $k = 0$ 时，不能交换，直接求出数值即可；

- 当 $k > 0$ 且 $n = 2$ 时，因为两次交换的结果会相抵消，根据 $k$ 的奇偶性确定这两个数各自不变是被交换 $1$ 次，直接求出数值的答案即可；

- 当 $k > 0$ 且 $n > 2$ 时，因为 $\forall 1 \leq i \leq n, m_i \leq \max_{1 \leq i \leq n} a_i$，所以考虑到所有 $m_i$，都取到这个上限。另一种方法是把数列的最大值换到数列的第一个位置，此时取到上限，然后的交换次数用原来的数互相直接消耗掉即可。

### 标程

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e5 + 5;
int T, n, k, a[N];
void solve() {
    long long res = 0;
    long long mx = 0;
    for (int i = 1; i <= n; i++) mx = max(mx, a[i]), res += mx;
    printf("%lld\n", res);
}

int main() {
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    if (k == 0) solve();
    else if (n == 2) {
        if (k & 1) swap(a[1], a[2]);
        solve();
    } else {
        for (int i = 2; i <= n; i++) {
            if (a[i] > a[1]) swap(a[i], a[1]);
        }
        solve();
    }
    return 0;
}
```