```markdown
此题为一分求最优解的模板

对于任务给出的“空隙”指数 $G$，我们应该怎么判断它是否符合题目 的意思呢？

我们可以想象，我们已经知道这条路上的所有的路标，我们从头开始枚举两个邻近的路标的间距，如果大于 $G$，那么已经不符合 $G$为最大距离的条件了，为了使 $G$ 满足，我们就可以在前一个路标前 $G$ 米处加一个路标，这样与前面一个就符合条件了，再判断新的路标和后面的路标是否是否距离小于 $G$，如果不是，继续重复设置新路标

当新的路标已经超过题目给出的最大设定值，如果还没有路标不满足距离 $G$，那么这个值就不满足条件。相反，则 $G$ 成立。

注意到，如果一个“空隙”指数成立，那么可能存在比它更小的解，但如果一个“空隙”指数不成立，那么答案只能比该值更大

确定了判断方法，我们就可以写二分的代码了：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>

using namespace std;
int sit[100005];
int L,N,K;
inline bool check(int m)
{
    int y=K;
    int size=0;//确定当前的比较位置
    for(int i=1;i<N;i++)
    {
        if(sit[i]-size<=m)
        {
            size=sit[i];//成立则移动比较位置，比较下一组
        }
        else
        {
            size=size+m;//设置新的路标，前一个路标已经满足，移动位置到新路标
            i--;//防止因为循环把之前的路标给移动走了！
            y--;//减少可用新路标数
        }
    }
    if(y>=0)
    {
        return true;
    }
    return false;
}
int main()
{
    cin>>L>>N>>K;
    int t=0;
    while(t<N)
    {
        cin>>sit[t];
        t++;
    }
    int H=0,R=L;
    int ans;
    while(H<=R)
    {
        int mid=H+(R-H)/2;
        if(check(mid))
        {
            ans=mid;//记录
            R=mid-1;//可能存在更小的“空隙”指数，搜索左区间
        }
        else
        {
            H=mid+1;//答案只能是更大的“空隙”指数，搜索右区间
        }
    }
    cout<<ans;
}
```
```