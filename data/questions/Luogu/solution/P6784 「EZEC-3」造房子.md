由题可知，$a$ 和 $b$ 类似于我们所说的“短板效应”，因为每一层的两头所需的数据量都是相同的，显然能够满足最高层是由其中较小的那一块决定的，所以我们要让较小的一类尽可能多，即考虑一个决策策略，尽可能让 $|a - b|$ 小，这样我们可以最大化地利用这些转头来造房子了。

假设我们能够做到使 $min(a, b) = s$，那么考虑的不同情况有：

- 普通情况：

因为我们可以将其分为三种情况，若$c$也视为一种转头，可以容易得到的最优解就是：

$$
s = \frac{a + b + c}{2}
$$

- 特殊情况

但是在某方情况有一个问题，如果用所有的 $c$ 都无法使得 $a$ 和 $b$ 的差满是最优情况，也就是当 $c < |a - b|$ 的时候，我们就只能返回来尝试是全部的 $c$ 来补救 $min(a, b)$ 的空间，也就是：

$$
s = min(a, b) + c
$$

接下来我们需要模拟模拟的过程，因为：

$$
\sum_{n=1}^{10^6} n = (1 + 10^6) \times 10^6 > 10^{12}
$$

所以简单的模拟次数不会超过 $10^6$，这样就可以简单的解决了，大体思路如下：

- 循环变量：每次加 1（$while$ 和 $for$ 皆可）。
- 用 $sum$ 叠加。

判断，如果 $sum > 8$ 就输出 $i - 1$。

当然如果你判断 $sum + i + 1 > s$ 输出也是可以的。

最后注意的是，范围到了 $10^{12}$，所以记得开 $long long$，同时使用到 $abs$ 需要用到 $cmath$ 库。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c,ans;
int main(){
    cin >> a >> b >> c;
    if(abs(a-b) < c) s=min(a,b)+c;
    else s=(a+b+c)/2;
    for(long long i=1;i<=s;i++){
        ans+=i;
        if(ans>s){
            cout<<i-1<<endl;
            return 0;
        }
    }
}
```

当然你完全可以对前 $\sqrt{8}$ 层楼用等差数列求和公式进行计算，然后再进行循环求解，这样可以大大优化原有程序的效率，改变部分代码如下：

```cpp
f=sqrt(s)-1;
ans+=(1+f)*f/2;
for(long long i=f+1;i<=i;i++){
        ans+=i;
        if(ans>s){
            cout<<i-1<<endl;
            return 0;
        }
}
```